#!/usr/bin/env bash

## 为什么不直接 `#!/usr/bash`？
# 因为 bash 不在 POSIX 标准中，不能默认用户有 bash，只能把 bash 作为显式依赖。

set -o pipefail # Not supported by POSIX shell
set -o errexit

# trap "trap - HUP && kill -s SIGHUP -$$" INT HUP TERM EXIT
## 为什么不需要转发信号？
# 进程组的语义就是一个不可分割的 job，因此应该在发送信号时直接发给整个进程组，而不是只发给组长然后让组长转发。

VERSION='0.0.1'


SUBCMD="$1"
case $SUBCMD in
	capture)
		MONGODB_HOST_URI="$2"
		MONGODB_DB_NAME="$3"
		S3_BUCKET_NAME="$4"
		S3_OBJECT_NAME="$5"
		for coll in "${@:6}"; do
			mongodump --uri="$MONGODB_HOST_URI" --db="$MONGODB_DB_NAME"\
				--username="$MONGO_USERNAME" --password="$MONGO_PASSWORD" \
				--archive --gzip \
				--collection="$coll" | \
				mc pipe "$MC_ALIAS/$S3_BUCKET_NAME/$S3_OBJECT_NAME"
		done
	;;
	restore)
		S3_BUCKET_NAME="$2"
		S3_OBJECT_NAME="$3"
		MONGODB_HOST_URI="$4"
		mc cat "$MC_ALIAS/$S3_BUCKET_NAME/$S3_OBJECT_NAME" | \
		mongorestore --uri="$MONGODB_HOST_URI" \
		--username="$MONGO_USERNAME" --password="$MONGO_PASSWORD" \
		--drop --archive --gzip
    ;;
	--version)
		echo "$VERSION"
	;;
	*)
		echo "Invalid subcommand."
		exit 1
	;;
esac
